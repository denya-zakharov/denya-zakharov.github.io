<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Responsive Portfolio with Overlay Menu</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <div class="aaa" id="menu-placeholder"></div> <!-- Placeholder for the menu -->
    <button class="menu-tab-button">
      <img class="icon" src="https://ucarecdn.com/07a52e24-4675-4eb3-9715-4a5444b541e3/" alt="Menu Icon" />
    </button>
    <div class="content-wrapper">
      <div class="text-section">
      <p>
        Currently, I am a UX Designer at Wargaming, working on World of Tanks. Since 2024, I have delivered over 15 features, ranging from functionality improvements (e.g. One-Trust Cookie Banner, Admin Pannel) to full redesigns of major tools, such as the WoT Portal or WoT Registration form. 
      </p>
      <p>
        Previously, I was part of the Design Department at Wrike, where I initially focused on creating marketing landing pages and banner campaigns. Later, as a member of the Web UX Team, I contributed to the design and optimization of Wrikeâ€™s website and blog.
      </p>
      <div class="contact" id="contact">
        <ul>
        <li><a href="https://www.linkedin.com/in/denis-zakharov-1b1197190/" target="_blank">Linked in</a></li>
        <li><a href="https://www.behance.net/5uperbro" target="_blank">Behance</a></li>
        </ul>
      </div>
      </div>
      <div class="image-section">
    <canvas id="sceneCanvas"></canvas>
      </div>
    </div>
  </div>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    console.log("DOM fully loaded and parsed");

    // Load the menu component
    const menuPlaceholder = document.getElementById("menu-placeholder");
    fetch("menu.html")
      .then(response => response.text())
      .then(data => {
        menuPlaceholder.innerHTML = data;
        console.log("Menu loaded successfully");

        // Menu open/close functionality
        const menuButton = document.querySelector('.menu-tab-button');
        const closeButton = document.querySelector('.close-tab-button');
        const menu = document.querySelector('.menu');

        const openMenu = () => {
          if (window.innerWidth <= 1100) { // Only for mobile and tablet
            if (menu) {
              menu.classList.add('menu-open'); // Add class to show the menu
              console.log("Menu opened");
            } else {
              console.error("Menu not found");
            }
          }
        };

        const closeMenu = () => {
          if (window.innerWidth <= 1100) { // Only for mobile and tablet
            if (menu) {
              menu.classList.remove('menu-open'); // Remove class to hide the menu
              console.log("Menu closed");
            } else {
              console.error("Menu not found");
            }
          }
        };

        // Attach click events to buttons
        if (menuButton) {
          menuButton.addEventListener('click', () => {
            console.log("Menu button clicked");
            openMenu();
          });
        } else {
          console.error("Menu button not found");
        }

        if (closeButton) {
          closeButton.addEventListener('click', () => {
            console.log("Close button clicked");
            closeMenu();
          });
        } else {
          console.error("Close button not found");
        }

        // Close menu when clicking on the blurred background
        const blurredBackground = document.querySelector('.menu');
          blurredBackground.addEventListener('click', (event) => {
            if (event.target === blurredBackground) {
              closeMenu();
            }
          });

        // Select all collapsible buttons
        const collapsibles = document.querySelectorAll('.collapsible');
        collapsibles.forEach(button => {
          button.addEventListener('click', () => {
            // Toggle the "expanded" class to rotate the arrow
            button.classList.toggle('expanded');

            // Find the next sibling (the nested list)
            const nestedList = button.nextElementSibling;
            if (nestedList) {
              // Toggle the display of the nested list
              nestedList.style.display = nestedList.style.display === 'block' ? 'none' : 'block';
            }
          });
        });
      })
      .catch(error => console.error("Error loading menu:", error));

    // Animate elements on the page
    const elementsToAnimate = document.querySelectorAll('.content-wrapper > *');
    elementsToAnimate.forEach((element, index) => {
      element.classList.add('fade-in', `fade-in-delay-${index}`);
    });
  });
</script>
<script>
  // Basic scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  50, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.set(0, 100, 0); // Set camera position on top of the cylinder
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("sceneCanvas"),
  antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);

document.body.appendChild(renderer.domElement);

// Enable OrbitControls for user interaction
const controls = new THREE.OrbitControls(camera, renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(0, 1, 1);
scene.add(directionalLight);

// Create a group to hold all text meshes
const textGroup = new THREE.Group();
scene.add(textGroup);

// Load the font and create text meshes arranged on a cylinder
const loader = new THREE.FontLoader();
loader.load(
  'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/fonts/helvetiker_regular.typeface.json',
  function (font) {
    const text = "Denis Zakharov";
    const textMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const count = 50;
    const radius = 30;
    const height = 60;
    const rows = 10;
    const cols = count / rows;
    const rowRotSpeeds = Array.from({ length: rows }, () => (Math.random() - 0.5) * 0.02);

    const rowGroups = [];
    for (let row = 0; row < rows; row++) {
      const rowGroup = new THREE.Group();
      rowGroups.push({ group: rowGroup, speed: rowRotSpeeds[row] });
      textGroup.add(rowGroup);

      for (let col = 0; col < cols; col++) {
        let angle = (col / cols) * Math.PI * 2;
        let x = Math.cos(angle) * radius;
        let z = Math.sin(angle) * radius;
        let y = ((row / (rows - 1)) - 0.5) * height;

        const geometry = new THREE.TextGeometry(text, {
          font: font,
          size: 3,
          height: 0.5,
          curveSegments: 12,
          bevelEnabled: false
        });
        geometry.computeBoundingBox();
        geometry.center();

        const mesh = new THREE.Mesh(geometry, textMaterial);
        mesh.position.set(x, y, z);
        mesh.lookAt(new THREE.Vector3(0, y, 0));
        mesh.rotateY(Math.PI);

        rowGroup.add(mesh);
      }
    }

    // Animation loop with individual row rotations
    function animate() {
      requestAnimationFrame(animate);
      textGroup.rotation.y += 0.002;
      rowGroups.forEach(row => {
        row.group.rotation.y += row.speed;
      });
      renderer.render(scene, camera);
      controls.update();
    }
    animate();
  }
);

// Adjust scene on window resize
window.addEventListener('resize', function () {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>